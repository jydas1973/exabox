#!/usr/bin/env python
#
# $Header: ecs/exacloud/exabox/tools/ebXmlGen/ebExacloudVanillaGenerator.py /main/7 2025/09/23 07:26:34 aararora Exp $
#
# ebExacloudVanillaGenerator.py
#
# Copyright (c) 2020, 2025, Oracle and/or its affiliates.
#
#    NAME
#      ebExacloudVanillaGenerator.py - <one-line expansion of the name>
#
#    DESCRIPTION
#      Vanilla XML Generator
#
#    NOTES
#      Confluence: https://confluence.oraclecorp.com/confluence/x/D_xSq
#
#    MODIFIED   (MM/DD/YY)
#    aararora    07/30/25 - ER 38132942: Single stack support for ipv6
#    ffrrodri    10/13/21 - Bug 33461178: Added method to order XML considering
#                           network elements ordered first by client and then
#                           backup.
#    jesandov    11/18/20 - Creation
#

import ipaddress
import os
import re
import sys
import copy
import json
import shlex
import subprocess as sp

from exabox.tools.ebTree.ebTree import ebTree
from exabox.tools.ebTree.ebTreeNode import ebTreeNode
from exabox.log.LogMgr import ebLogError, ebLogInfo, ebLogWarn

class ebExacloudVanillaGenerator:

    def __init__(self, aUUID, aCallbackInfo, aSaveDir="log/xmlgen"):
        """
        Constructor

        :param:aUUID:UUID of the operation
        :param:aCallbackInfo: CallbackInfo generated by ebCallbackInfo
        :param:aSaveDir:Location where to record  every step exection
        """

        self.__uuid = aUUID
        self.__callbackInfo = copy.deepcopy(aCallbackInfo)
        self.__vanillaXML = None
        self.__saveDir = aSaveDir
        self.__exatemplateXML = ebTree("exabox/tools/ebOedacli/exatemplateV1.tpl")


    #######################
    # GETTERS AND SETTERS #
    #######################

    def mGetUUID(self):
        return self.__uuid

    def mSetUUID(self, aValue):
        self.__uuid = aValue

    def mGetCallbackInfo(self):
        return self.__callbackInfo

    def mSetCallbackInfo(self, aValue):
        self.__callbackInfo = aValue

    def mGetVanillaXML(self):
        return self.__vanillaXML

    def mSetVanillaXML(self, aValue):
        self.__vanillaXML = aValue

    def mGetSaveDir(self):
        return self.__saveDir

    def mSetSaveDir(self, aValue):
        self.__saveDir = aValue

    def mGetExatemplateXML(self):
        return self.__exatemplateXML

    def mSetExatemplateXML(self, aValue):
        self.__exatemplateXML = aValue

    #################
    # CLASS METHODS #
    #################

    def mInit(self):
        _vanilla = self.mGetExatemplateXML().mCopy()
        self.mSetVanillaXML(_vanilla)

    def mExecuteLocal(self, aCmd, aCurrDir=None, aStdIn=sp.PIPE, aStdOut=sp.PIPE, aStdErr=sp.PIPE):

        _args = aCmd
        if isinstance(aCmd, str):
            _args = shlex.split(aCmd)

        _current_dir = aCurrDir
        _stdin = aStdIn
        _stdout = aStdOut
        _stderr = aStdErr

        _proc = sp.Popen(_args, stdin=_stdin, stdout=_stdout, stderr=_stderr, cwd=_current_dir)
        _stdoutP, _stderrP = _proc.communicate()
        _rc = _proc.returncode

        if _stdoutP:
            _stdoutP = _stdoutP.decode("UTF-8").strip()
        else:
            _stdoutP = ""

        if _stderrP:
            _stderrP = _stderrP.decode("UTF-8").strip()
        else:
            _stderrP = ""

        return _rc, _stdoutP, _stderrP


    def mExecute(self):
        """
        Execute the step to generate the Vanilla XML
        """

        # Init the Vanilla XML
        self.mInit()

        # Process XML Callbacks
        self.mProcessCallbacksXML()
        self.mAddExtraInformation()
        self.mSaveVanillaXML("p2-1-GenerateVanilla")

    def mSortElements(self, aTreeNode, aArgs):

        def mNetworkSort(aNode):

            _sortkey = ""

            if "id" in aNode.mGetElement():

                if aNode.mGetSortElement() == "network":

                    if "_client" in aNode.mGetElement()['id']:
                        _sortkey = "1"

                    elif "_backup" in aNode.mGetElement()['id']:
                        _sortkey = "2"

                    else:
                        _sortkey = "3"

            _sortkey = f"{_sortkey}/{aNode.mCalculateSortKey()}"

            return _sortkey

        if aTreeNode.mGetChildren():
            aTreeNode.mGetChildren().sort(key=lambda x: mNetworkSort(x), reverse=True)

    def mAddExtraInformation(self):
        """
        Additional call to add extra information to the final Vanilla XML
        """

        _root = self.mGetVanillaXML().mGetRoot()
        _root.mGetElement()['filetype'] = "PAAS"
        _root.mGetElement()['oedaversion'] = "17.089.19:00"

        for _child in list(_root.mGetChildren()):

            if _child.mGetSortElement() == "customerName":
                if not _child.mGetElement()['text']:
                    _child.mGetElement()['text'] = self.mGetUUID().replace("-", "")

            if _child.mGetSortElement() in ["actions", "configKeys"]:
                _child.mRemove()

        # Add Elastic shape tag
        _newNode = ebTreeNode()
        _newNode.mSetElement({"tag": "XmlElasticShape", "text": "true"})
        _root.mAppendChild(_newNode)

        self.mGetVanillaXML().mBFS(aStuffCallback=self.mSortElements)

    def mSaveVanillaXML(self, aTag):
        """
        Save Vanilla XML in one file

        :param:aTag:Sufix of the name of the file
        """

        os.makedirs(self.mGetSaveDir(), exist_ok=True)

        _path = "{0}/{1}_{2}_vanilla.xml".format(self.mGetSaveDir(), self.mGetUUID(), aTag)
        self.mGetVanillaXML().mExportXml(_path, aDisplaySortKey=True)

    def mIsIPV6Address(self, aIP):
        try:
            ipaddress.IPv6Address(aIP)
            return True
        except ValueError:
            return False

    def mReplaceCallbackTree(self, aValueCallback, aTreeNode, aStartIdx):
        """
        Change information of one XML TreeNode with aValueCallback

        :param:aValueCallback: CallbackInfo with the information to replace
        :param:aTreeNode: Node in the XML to add the information
        :return: New TreeNode with the information of the CallbackInfo
        """

        def mGetChildByName(aNode, aName):
            for _child in aNode.mGetChildren():
                if _child.mGetSortElement() == aName:
                    return _child
            return None

        # Get the parent and the new value
        _parent = aTreeNode.mGetParent()
        _replace = ebTree.mDeepCopyNode(aTreeNode)
        _replace.mSetSortKey(aStartIdx)
        _toRemove = []

        for _callbackKey, _callbackValue in aValueCallback.items():

            _node = _replace
            _callbackPath = _callbackKey.split(":")

            for _path in _callbackPath:
                if _node:
                    _node.mGetElement()['found'] = True
                    _node = mGetChildByName(_node, _path)

            if not _node:
                continue
            else:
                _node.mGetElement()['found'] = True

            # Replace the value
            if isinstance(_callbackValue, list):

                # Check the deep of the node
                _refNode = _node
                _deep = 0

                while _refNode.mGetChildren():
                    _refNode = _refNode.mGetChildren()[0]
                    _deep += 1

                if _deep == 0:
                    _tplNode = _node
                    _tplNode.mGetElement()['found'] = True

                else:
                    _tplNode = _node.mGetChildren()[0]
                    _tplNode.mGetElement()['found'] = True

                _cbIdx = 1
                for _value in _callbackValue:

                    # the dicts will be apply as normal callbacks
                    if isinstance(_value, dict):

                        if _deep == 1:
                            self.mReplaceCallbackTree(_value, _node, aStartIdx + _cbIdx + 1)

                        else:
                            self.mReplaceCallbackTree(_value, _tplNode, aStartIdx + _cbIdx + 1)

                        _cbIdx += 1
                        continue

                    # Get the value from the templace
                    _valueNode = ebTree.mDeepCopyNode(_tplNode)
                    _valueNode.mGetElement()['found'] = True
                    _inserted = False

                    _valueCount = 1
                    for _toInsert in _value.split(","):

                        try:
                            # Here, the callback value can be an ipv6 address
                            # which can cause issues while parsing and setting
                            # value for an ip address if split is done on ":"
                            if self.mIsIPV6Address(_toInsert):
                                _insertAt = "id"
                                _insertValue = _toInsert
                            else:
                                _insertAt = _toInsert.split(":")[0]
                                _insertValue = _toInsert.split(":")[1]
                        except IndexError:
                            _insertAt = "id"
                            _insertValue = _toInsert

                        # Add the value evaluation the deep on the tree
                        if _deep == 0:

                            _valueNode.mGetElement()[_insertAt] = _insertValue
                            _node.mGetParent().mGetElement()['found'] = True

                            if not _inserted:
                                _node.mGetParent().mAppendChild(_valueNode)
                                _inserted = True

                        elif _deep == 1:

                            _valueNode.mGetElement()[_insertAt] = _insertValue
                            _node.mGetElement()['found'] = True

                            if not _inserted:
                                _node.mAppendChild(_valueNode)
                                _inserted = True

                        elif _deep == 2:

                            _valueNode.mGetChildren()[0].mGetElement()[_insertAt] = _insertValue
                            _node.mGetElement()['found'] = True

                            if not _inserted:
                                _node.mAppendChild(_valueNode)
                                _inserted = True

                        _valueNode.mSetSortKey(aStartIdx + _cbIdx +  _valueCount)
                        _valueCount += 1

                    _cbIdx += 1

                _tplNode.mRemove()

            else:

                _valueCount = 1
                for _toInsert in _callbackValue.split(","):

                    try:
                        # Here, the callback value can be an ipv6 address
                        # which can cause issues while parsing and setting
                        # value for an ip address if split is done on ":"
                        if self.mIsIPV6Address(_toInsert):
                            _insertAt = "text"
                            _insertValue = _toInsert
                        else:
                            _insertAt = _toInsert.split(":")[0]
                            _insertValue = _toInsert.split(":")[1]
                    except IndexError:
                        _insertAt = "text"
                        _insertValue = _toInsert

                    _node.mGetElement()[_insertAt] = _insertValue
                    _node.mGetElement()['found'] = True

                    _node.mSetSortKey(aStartIdx + _valueCount)
                    _valueCount += 1


        # Aditional information
        _replace.mGetElement()['id'] = aValueCallback['id']

        # Remove not necessary nodes
        _toRemove = []
        for _node in _replace.mGetChildren():
            if "found" not in _node.mGetElement():
                _toRemove.append(_node)

        for _node in _toRemove:
            _node.mRemove()

        # Insert the new creatd child to the tree
        _parent.mAppendChild(_replace)
        return _replace


    def mCleanTree(self, aTreeNode, aArgs):
        """
        ebTree mStuff method
        Clean the information of the Exacloud Vanilla XML

        :param:aTreeNode:XMLNode to clean
        :param:aArgs:Dummy extra information required to mStuff interface
        """

        # Remove erased elements
        if "text" in aTreeNode.mGetElement() and \
           aTreeNode.mGetElement()['text'] == "erased":

            aTreeNode.mRemove()
            return

        # Add default version
        if aTreeNode.mGetSortElement() == "version" and not aTreeNode.mGetElement()['text']:
            aTreeNode.mGetElement()['text'] = "2"

        # Remove unnused tags 
        for _key in list(aTreeNode.mGetElement().keys()):

            # Remove the xmlgen template nodes
            if _key == "xmlgen" and "id" not in aTreeNode.mGetElement():
                aTreeNode.mRemove()

            # Remove not used tags
            if _key not in ['text', 'id', 'xmlns', 'tag']:
                del aTreeNode.mGetElement()[_key]


    def mFindCallbackInTree(self, aTreeNode, aCallbackName):
        """
        ebTree mStuff Comparation method
        Compare one node with the callbackname in the exatemplateV1.xml

        :param:aTreeNode: Node to compare
        :param:aCallbackname: Name of the callback to find
        :return: True if the node contains the xmlgen value withe the aCallbackName
        """

        if "xmlgen" in aTreeNode.mGetElement() and \
           aTreeNode.mGetElement()['xmlgen'] == aCallbackName:
               return True

        return False

    def mExecuteCodeCallbacks(self, aCodeCallbackName, aTreeNode):
        """
        Execute code callbacks

        :param:aCallbackName: Code Callback to execute 
        :param:aTreeNode: Node that will be affected by the Callback
        """

        if aCodeCallbackName == "detect_nat_ip":

            _natipNode = None
            _natip = ""
            _nathost = ""
            _natdomain = ""

            for _child in aTreeNode.mGetChildren():

                if _child.mGetSortElement() == "natipAddress":
                    _natip = _child.mGetElement()['text']
                    _natipNode = _child

                if _child.mGetSortElement() == "nathostName":
                    _nathost = _child.mGetElement()['text']

                if _child.mGetSortElement() == "natdomainName":
                    _natdomain = _child.mGetElement()['text']

            if _natip == "discover":

                _natfqdn = f"{_nathost}.{_natdomain}"

                _cmd = f"/usr/bin/nslookup {_natfqdn}"
                _rc, _o, _e = self.mExecuteLocal(_cmd)

                if _rc == 0:
                    _hostname = re.search("Address:\s+(([0-9]{1,3}\.){3}[0-9]{1,3})$", _o)
                    if _hostname and _natipNode:
                        _natipNode.mGetElement()['text'] = _hostname.group(1)


        if aCodeCallbackName == "remove_empty_children":

            _toRemove = []
            for _child in aTreeNode.mGetChildren():

                self.mExecuteCodeCallbacks(aCodeCallbackName, _child)

                _element = _child.mGetElement()
                _id = ""
                _text = ""
                _children = _child.mGetChildren()

                if "id" in _element:
                    _id = _element['id']

                if "text" in _element:
                    _text = _element['text']

                if _id == "" and _text == "" and not _children:
                    _toRemove.append(_child)


            for _removed in _toRemove:
                _removed.mRemove()

    def mProcessCallbacksXML(self):
        """
        Iterate all the callbacks and change the XML information with every callback found
        using the BFS search method to find the node and apply the changes
        """

        _idxCount = 0
        for _callback in self.mGetCallbackInfo():

            _callbackName = _callback['xml_callback']

            _direct = False
            if "xml_direct_callback" in _callback and \
               str(_callback['xml_direct_callback']).upper() == "TRUE":
                    _direct = True

            if _callbackName == "deleted":
                continue

            _treeNode = self.mGetVanillaXML().mBFS(aElement=_callbackName, \
                                                   aCompareCallback=self.mFindCallbackInTree)

            if not _treeNode:
                ebLogWarn("Missing {0} in tree: {1}".format(_callbackName, _callback))
                continue

            if _direct:

                if "id" in _callback['values']:
                    _treeNode.mGetElement()['id'] = _callback['values']['id']

                if "text" in _callback['values']:
                    _treeNode.mGetElement()['text'] = _callback['values']['text']

                _treeNode.mSetSortKey(_idxCount*10000)

            else:

                _replaced = self.mReplaceCallbackTree(_callback['values'], _treeNode, _idxCount*10000)

                # Execute code callbacks
                if "code_callbacks" in _callback:
                    for _codeCallback in _callback['code_callbacks']:
                        self.mExecuteCodeCallbacks(_codeCallback, _replaced)

            _idxCount += 1

        # Clean the tree of unused tags
        self.mGetVanillaXML().mBFS(aStuffCallback=self.mCleanTree)


# end of file
