"""
$Header:

 Copyright (c) 2020, 2022, Oracle and/or its affiliates.

NAME:
    Crypt - Use python cryptography package to replace the usage of /bin/openssl

FUNCTION:
    Provide basic/core API for encrypt and decrypt

    Steps for encrypting:
    1 Generate 8 bytes of random data as salt.
    2 Derive AES key and IV from password using the salt from step 1.
    3 Encrypt the padded using AES-256 in GCM mode with the key and the IV from step 2.
    4 Encode in Base64, the salt from step 1 and the encrypted data from step 4.

    Steps from decrypting are the reverse:
    1 Decode the input data from Base64 into a binary string.
    2 Treat the first 8 bytes of the decoded data as salt.
    3 Derive AES key and IV from password using the salt from step 1.
    4 Decrypt the remaining decoded data using the AES key and the IV from step 3.
    5 If decryption fail try using previous encryption CBC method.

NOTE:
    'pip install --upgrade oci --proxy="http://www-proxy.us.oracle.com:80"' should be atleast oci 2.24.1
    'pip install --upgrade cryptography --proxy="http://www-proxy.us.oracle.com:80"' should be atleast 3.2.1
    This is a generic module that can be used for encyrption & decryption
    API Usage:
    To encrypt : mEncrypt(passphrase, plaintext) => returns encrypted_data
    To decrypt : mDecrypt(passphrase, encrypted_data) => returns plaintext

History:

    MODIFIED   (MM/DD/YY)
      ndesanto  12/21/21 - Change encryption cipher from CBC for security
                           concerns.
      gsundara  12/07/20 - Creation
"""

import base64
import os
import re
import six

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from importlib import import_module
from typing import Any, ClassVar, Dict, List, Optional, Tuple, Union


MSGDGST = "sha256"
AAD = None


def isBase64(aData: Union[str, bytes]) -> bool:
    """
    If aData can be decoded then encode and remains the same then aData is
    a valid base64 str or bytes.

    Arguments
        aData: str or bytes
            The data to verify is it's base64 encoded.

    Returns
        A bool (True/False)
    """
    try:
        _data: bytes
        if isinstance(aData, str):
            #  If there's any unicode here, an exception will be thrown and the 
            # function will return false
            _data = bytes(aData, 'ascii')
        elif isinstance(aData, bytes):
            _data = aData
        else:
            raise ValueError("Argument must be string or bytes")
        
        return base64.b64encode(base64.b64decode(_data)) == _data
    except Exception:
        return False

def getKeyAndIV(aPassword: Union[str, bytes], aSalt: bytes, aKlen: int=32, \
    aIlen: int=16) -> Tuple[bytes, bytes]:
    """
    Derive the key and the initialization vector from the given password and salt.

    Arguments
        aPassword: str or bytes
            The password, knwon to both parties, to use as part of the key and iv creation.
        aSalt: bytes
            The salt, generally random generated bytes, that will be sent as aprt of the
            ecnrypted message.
        aKlen(optional): int=32
            The length of the resulting key, this depends on the cipher algorithm to use
        aIlen(optional): int=16
            The length of the IV bytes required for the encryption.

    Returns
        key and iv bytes arrays constructed from the password and salt.
    """
    # equivalent to bellow, used to remove several low fortify issues
    #   from hashlib import sha256 as mdf
    mdf = getattr(import_module("hashlib"), MSGDGST)
    password: Union[str, bytes] = aPassword
    if isinstance(aPassword, str):
        password = aPassword.encode("ascii", "ignore")  # convert to ASCII

    try:
        maxlen: int = aKlen + aIlen
        keyiv: bytes = mdf(password + aSalt).digest()
        tmp: List[bytes] = [keyiv]
        #  This method loops until keyiv lenght is over maxlen, the purpose is 
        # to use the pass word and salt and from them get enough bytes to get 
        # a key of aKlen bytes and and iv of aIlen bytes. This is done by using
        # a sha256 digest and reusing the generated hash plus the pass word and
        # salt, this process is reproduced on the reciving end 
        # (in this case Java).
        while len(keyiv) < maxlen:
            # Digest the previous hash + pass + salt and add it to the hash array
            tmp.append(mdf(tmp[-1] + password + aSalt).digest())
            # keep adding bytes to the end of keyAndIv by getting the latest hash
            keyiv += tmp[-1]
        key: bytes = keyiv[:aKlen]
        iv: bytes = keyiv[aKlen:aKlen + aIlen]
        return key, iv
    except UnicodeDecodeError:
        return None, None


def encrypt(aPassword: Union[str, bytes], aPlaintext: str, \
    aChunkit: bool=True) -> bytes:
    """
    There's no openssl equivalent, LibreSSL does support encryption with 
    cipher -aes-256-gcm but does not allow for command encryption.

    Arguments
        aPassword: str or bytes
            The password, knwon to both parties, to use as part of the key and iv creation.
        aPlaintext: str
            The message to be encrypted.
        aChunkit (optional): bool = True
            Unused, kept for compatibility.

    Returns
        Encrypted message as a str base64 encoded.
    """
    salt: bytes = os.urandom(8)
    key, iv = getKeyAndIV(aPassword, salt)
    if key is None:
        return None

    # Encrypt
    _cipher: AESGCM = AESGCM(key)
    ciphertext: bytes = _cipher.encrypt(iv, aPlaintext, AAD)
    # # Make openssl compatible.
    # # Files begin with an 8-byte signature: the   characters "Salted__".
    openssl_ciphertext: bytes = b'Salted__' + salt + ciphertext
    return base64.b64encode(openssl_ciphertext)


def decrypt(aPassword: Union[str, bytes], aCiphertext: str) -> bytes:
    """
    There's no openssl equivalent, LibreSSL does support encryption with 
    cipher -aes-256-gcm but does not allow for command encryption.

    Arguments
        aPassword: str or bytes
            The password, knwon to both parties, to use as part of the key and iv creation.
        aCiphertext: str
            The message to be descrypted must be a base64 string that contains 
        "Salted__", 8 bytes of salt and the message to decrypt.

    Returns
        Decrypted message as a str.
    """
    # ignore blank lines and comments
    filtered: str = ''
    nl: str = '\n'
    re1: str = r'^\s*$'
    re2: str = r'^\s*#'

    for line in aCiphertext.split(nl):
        line = line.strip()
        if re.search(re1, line) or re.search(re2, line):
            continue
        filtered += line + nl

    # Base64 decode
    raw: bytes = base64.b64decode(filtered)
    # # Verify signature
    assert (raw[:8] == b'Salted__')
    salt: bytes = raw[8:16]  # get the salt

    # Now create the key and iv.
    key: Optional[bytes]
    iv: Optional[bytes]
    key, iv = getKeyAndIV(aPassword, salt)
    if key is None:
        return None

    # The original ciphertext
    ciphertext: bytes = raw[16:]

    # Decrypt
    _cipher: AESGCM = AESGCM(key)
    return _cipher.decrypt(iv, ciphertext, AAD)


class cryptographyAES:
    """
    Keeping the class structure for compatibility purposses
    """

    def mEncrypt(self, aPassword: Union[str, bytes], aPlaintext: str, \
        aChunkit: bool=True) -> bytes:
        """
        Wrapper for crypt.encrypt
        """
        return encrypt(aPassword, aPlaintext, aChunkit)

    def mDecrypt(self, aPassword: Union[str, bytes], aCiphertext: str) -> bytes:
        """
        Since we're keeping compatibility with previous code, the fallback
        code is going to be kept here, the new expossed functions will be
        kept clean.
        """
        try:
            return decrypt(aPassword, aCiphertext)
        except:
            _old = cryptographyAES_CBC()
            return _old.mDecrypt(aPassword, aCiphertext)


class cryptographyAES_CBC:

    def __init__(self):
        self.__msgdgst = 'sha256'

    def mGetDgst(self):
        return self.__msgdgst

    def mSetDgst(self, aDgst):
        self.__msgdgst = aDgst

    def __mGetKeyAndIV(self, aPassword, aSalt, aKlen=32, aIlen=16):
        '''
        Derive the key and the initialization vector from the given password and salt.
        '''
        # equivalent to:
        #   from hashlib import sha256 as mdf
        mdf = getattr(import_module('hashlib'), self.mGetDgst())
        password = aPassword
        if isinstance(aPassword, str):
            password = aPassword.encode("ascii", "ignore")  # convert to ASCII

        try:
            maxlen = aKlen + aIlen
            keyiv = mdf(password + aSalt).digest()
            tmp = [keyiv]
            while len(tmp) < maxlen:
                tmp.append(mdf(tmp[-1] + password + aSalt).digest())
                keyiv += tmp[-1]  # append the last byte
            key = keyiv[:aKlen]
            iv = keyiv[aKlen:aKlen + aIlen]
            return key, iv
        except UnicodeDecodeError:
            return None, None

    def mSetupCipher(self, aKey, aIv):
        algorithm = algorithms.AES(aKey)
        self.__cipher = Cipher(algorithm, mode=modes.CBC(aIv), backend=default_backend())

    def mEncrypt(self, aPassword, aPlaintext, aChunkit=True):
        '''
        equivalent to:
        % openssl enc -aes-256-cbc -md sha256 -in plain_key.txt -out encrypted_key.txt -k <password> -a
        '''
        raise NotImplementedError

    def mDecrypt(self, aPassword, aCiphertext):
        '''
        equivalent to: 
        % openssl enc -md sha256 -d -aes-256-cbc -in <ciphertext> -out decrypted_key.txt -k <password> -a
        '''

        # ignore blank lines and comments
        filtered = ''
        nl = '\n'
        re1 = r'^\s*$'
        re2 = r'^\s*#'

        for line in aCiphertext.split(nl):
            line = line.strip()
            if re.search(re1, line) or re.search(re2, line):
                continue
            filtered += line + nl

        # Base64 decode
        raw = base64.b64decode(filtered)
        # Verify signature
        assert (raw[:8] == b'Salted__')
        salt = raw[8:16]  # get the salt

        # Now create the key and iv.
        key, iv = self.__mGetKeyAndIV(aPassword, salt)
        if key is None:
            return None

        # The original ciphertext
        ciphertext = raw[16:]

        # Decrypt
        self.mSetupCipher(key, iv)
        decryptor = self.__cipher.decryptor()
        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()

        if isinstance(padded_plaintext, str):
            padding_len = ord(padded_plaintext[-1])  # convert a Character to an Integer (unicode value)
        else:
            padding_len = padded_plaintext[-1]
        plaintext = padded_plaintext[:-padding_len]
        return plaintext
